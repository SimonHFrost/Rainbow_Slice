<html>
	<head>
		<title>Roller Ball</title>
		<style>canvas { width: 100%; height: 100% }</style>
	</head>
	<body>
    <script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
    <script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/effects/AsciiEffect.js"></script>
		<script src="https://rawgithub.com/mrdoob/three.js/master/examples/js/controls/OrbitControls.js"></script>
    <script src="keyboard.js"></script>

		<script>
			var container;
			var camera, scene, renderer, controls;
			var sphere, plane;
			var collidableMeshList = [];

			var ASCIIFY = false;

			init();
			animate();

			function init() {
				var width = window.innerWidth || 2 - 20;
				var height = window.innerHeight || 2 - 20;

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, width / height, 1, 2500 );
				camera.position.y = 2000;
				camera.rotation.x = -Math.PI / 2;

				scene = new THREE.Scene();

				var pointLight = new THREE.PointLight( 0xffffff );
				pointLight.position.set( 500, 500, 500 );
				scene.add( pointLight );

				var ambientLight = new THREE.AmbientLight( 0x707070 );
				scene.add( ambientLight );

				initSceneObjects();

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( width, height );

				// ASCII Effect
				effect = new THREE.AsciiEffect( renderer );
				effect.setSize( width, height );
				if(ASCIIFY) {
					container.appendChild( effect.domElement );
				} else {
					container.appendChild( renderer.domElement );
				}

				controls = new THREE.OrbitControls(camera, renderer.domElement);

				window.addEventListener( 'resize', onWindowResize, false );
      }

			function initSceneObjects() {
				// Sphere
				sphere = new THREE.Mesh( new THREE.SphereGeometry( 100, 20, 10 ), new THREE.MeshLambertMaterial( { shading: THREE.FlatShading } ) );
				sphere.position.z = -300;
				scene.add( sphere );

				MakeEnemies();

				// Floor
				var floorWidth = 1600;
				var floorHeight = 900;
				var textureSize = 256;

				var material
				if (ASCIIFY) {
					material = new THREE.MeshLambertMaterial( { shading: THREE.FlatShading, color: 0x00CC33 } );
				} else {
					// previous texture implementation is broken, use this for now
					material = new THREE.MeshLambertMaterial( { shading: THREE.FlatShading, color: 0x00CC33 } );

					/*
					texture = THREE.ImageUtils.loadTexture('grass.jpg');
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.set( floorWidth / textureSize, floorHeight / textureSize );
					material = new THREE.MeshBasicMaterial({map: texture});
					*/
				}

				floor = new THREE.Mesh( new THREE.PlaneGeometry( floorWidth, floorHeight ), material );
				floor.position.y = - 100;
				floor.rotation.x = - Math.PI / 2;
				scene.add( floor );
			}

			function MakeEnemies() {
				var numEnemies = 10;
				var spacing = 250;
				for(var i = 0; i < numEnemies; i++) {
					var geometry = new THREE.CubeGeometry( 200, 200, 200 );
					var material = new THREE.MeshBasicMaterial( {color: 0xFFFFFF} );
					var cube = new THREE.Mesh( geometry, material );
					cube.position.x = i * spacing - numEnemies * spacing / 2;
					scene.add( cube );
					collidableMeshList.push( cube );
				}
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				if(ASCIIFY) {
					effect.setSize( window.innerWidth, window.innerHeight );
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				var translationSpeed = 15;

				if (Key.isDown(Key.A)) {
        	sphere.position.x -= translationSpeed;
        }

				if (Key.isDown(Key.D)) {
					sphere.position.x += translationSpeed;
				}

				if (Key.isDown(Key.W)) {
					sphere.position.z -= translationSpeed;
				}

				if (Key.isDown(Key.S)) {
					sphere.position.z += translationSpeed;
				}

				if (ASCIIFY) {
					effect.render( scene, camera );
				} else {
					renderer.render( scene, camera );
				}

				controls.update();

				var originPoint = sphere.position.clone();
				for (var vertexIndex = 0; vertexIndex < sphere.geometry.vertices.length; vertexIndex++)
				{
					var localVertex = sphere.geometry.vertices[vertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( sphere.matrix );
					var directionVector = globalVertex.sub( sphere.position );

					var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
					var collisionResults = ray.intersectObjects( collidableMeshList );
					if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
						collisionResults[0].object.material = new THREE.MeshBasicMaterial( {color: 0xCC0000} );
					}
				}
			}

		</script>
	</body>
</html>
